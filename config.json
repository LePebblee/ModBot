{
    "token": "YOUR_DISCORD_BOT_TOKEN",
    "log_channel_id": "LOG_CHANNEL_ID",
    "main_server": "MAIN_SERVER_ID",
    "app_server": "APPEAL_SERVER_ID",
    "app_channel_id": "APPEAL_CHANNEL_ID",
    "application_invite_link": "https://discord.gg/YOUR_INVITE_LINK",
    "custom_commands": {
        "sync": "await client.tree.sync(guild=interaction.guild)\nawait interaction.response.send_message(\"Guild commands synced successfully.\", ephemeral=True)",
        "ban": "import discord, json, os\nfrom datetime import datetime\nfrom log_helper import add_log\n\nclass BanModal(discord.ui.Modal, title=\"Ban User\"):\n    user_id = discord.ui.TextInput(label=\"User ID\", placeholder=\"User ID here\", required=True)\n    reason = discord.ui.TextInput(label=\"Reason\", style=discord.TextStyle.paragraph, required=False)\n\n    async def on_submit(self, interaction: discord.Interaction):\n        try:\n            user = discord.Object(id=int(self.user_id.value))\n            await interaction.guild.ban(user, reason=self.reason.value)\n            # ----- LOGGING -----\n            add_log({\n                \"type\": \"ban\",\n                \"user_id\": self.user_id.value,\n                \"reason\": self.reason.value or \"No reason given\",\n                \"timestamp\": datetime.utcnow().strftime(\"%Y-%m-%d %H:%M:%S\")\n            })\n            await interaction.response.send_message(f\"Banned user {self.user_id.value}.\", ephemeral=True)\n        except Exception as e:\n            await interaction.response.send_message(f\"Error: {e}\", ephemeral=True)\n\nawait interaction.response.send_modal(BanModal())",
        "kick": "import discord, json, os\nfrom datetime import datetime\nfrom log_helper import add_log\n\nclass KickModal(discord.ui.Modal, title=\"Kick User\"):\n    user_id = discord.ui.TextInput(label=\"User ID\", placeholder=\"User ID here\", required=True)\n    reason = discord.ui.TextInput(label=\"Reason\", style=discord.TextStyle.paragraph, required=False)\n\n    async def on_submit(self, interaction: discord.Interaction):\n        try:\n            member = interaction.guild.get_member(int(self.user_id.value))\n            if member:\n                await member.kick(reason=self.reason.value)\n                # ----- LOGGING -----\n                add_log({\n                    \"type\": \"kick\",\n                    \"user_id\": self.user_id.value,\n                    \"reason\": self.reason.value or \"No reason given\",\n                    \"timestamp\": datetime.utcnow().strftime(\"%Y-%m-%d %H:%M:%S\")\n                })\n                await interaction.response.send_message(f\"Kicked {member.name}.\", ephemeral=True)\n            else:\n                await interaction.response.send_message(\"Member not found.\", ephemeral=True)\n        except Exception as e:\n            await interaction.response.send_message(f\"Error: {e}\", ephemeral=True)\n\nawait interaction.response.send_modal(KickModal())",
        "timeout": "import discord, json, os\nfrom datetime import datetime, timedelta\nfrom log_helper import add_log\n\nclass TimeoutModal(discord.ui.Modal, title=\"Timeout User\"):\n    user_id = discord.ui.TextInput(label=\"User ID\", placeholder=\"User ID here\", required=True)\n    minutes = discord.ui.TextInput(label=\"Duration (Minutes)\", placeholder=\"60\", required=True)\n    reason = discord.ui.TextInput(label=\"Reason\", style=discord.TextStyle.paragraph, required=False)\n\n    async def on_submit(self, interaction: discord.Interaction):\n        try:\n            member = interaction.guild.get_member(int(self.user_id.value))\n            if member:\n                duration = timedelta(minutes=int(self.minutes.value))\n                await member.timeout(duration, reason=self.reason.value)\n                # ----- LOGGING -----\n                add_log({\n                    \"type\": \"timeout\",\n                    \"user_id\": self.user_id.value,\n                    \"reason\": self.reason.value or f\"Timed out for {self.minutes.value} minutes\",\n                    \"timestamp\": datetime.utcnow().strftime(\"%Y-%m-%d %H:%M:%S\")\n                })\n                await interaction.response.send_message(f\"Timed out {member.name} for {self.minutes.value}m.\", ephemeral=True)\n            else:\n                await interaction.response.send_message(\"Member not found.\", ephemeral=True)\n        except Exception as e:\n            await interaction.response.send_message(f\"Error: {e}\", ephemeral=True)\n\nawait interaction.response.send_modal(TimeoutModal())",
        "accept": "import discord, json, os\nfrom datetime import datetime\nfrom log_helper import add_log\n\nclass AcceptModal(discord.ui.Modal, title='Accept Appeal'):\n    user_id = discord.ui.TextInput(label='User ID', placeholder='User ID to act upon', required=True)\n    reason = discord.ui.TextInput(label='Reason', style=discord.TextStyle.paragraph, required=False)\n\n    def __init__(self, action_type: str):\n        super().__init__()\n        self.action_type = action_type\n\n    async def on_submit(self, interaction: discord.Interaction):\n        try:\n            cfg_file = 'config.json'\n            if os.path.exists(cfg_file):\n                with open(cfg_file, 'r', encoding='utf-8') as f:\n                    cfg = json.load(f)\n            else:\n                await interaction.response.send_message('Config file not found.', ephemeral=True)\n                return\n\n            main_server_id = cfg.get('main_server')\n            if not main_server_id:\n                await interaction.response.send_message('Main server ID not configured.', ephemeral=True)\n                return\n\n            guild = interaction.client.get_guild(int(main_server_id))\n            if not guild:\n                await interaction.response.send_message(f'Could not find main server {main_server_id}.', ephemeral=True)\n                return\n\n            user_obj = discord.Object(id=int(self.user_id.value))\n            user_mention = f'<@{self.user_id.value}>'\n\n            if self.action_type == 'Unban':\n                await guild.unban(user_obj, reason=self.reason.value)\n                action_msg = f'Appeal Accepted. Unbanned {user_mention}.'\n            elif self.action_type == 'Untimeout':\n                member = guild.get_member(int(self.user_id.value))\n                if member:\n                    await member.timeout(None, reason=self.reason.value)\n                    action_msg = f'Appeal Accepted. Removed timeout from {user_mention}.'\n                else:\n                    try:\n                        member = await guild.fetch_member(int(self.user_id.value))\n                        await member.timeout(None, reason=self.reason.value)\n                        action_msg = f'Appeal Accepted. Removed timeout from {user_mention}.'\n                    except:\n                        await interaction.response.send_message(f'Could not find member {self.user_id.value} to remove timeout.', ephemeral=True)\n                        return\n            elif self.action_type == 'Unkick':\n                action_msg = f'Appeal Accepted. Kick overturned for {user_mention}. User may need to rejoin via invite.'\n            else:\n                await interaction.response.send_message(f'Unknown action: {self.action_type}', ephemeral=True)\n                return\n\n            add_log({\n                'type': self.action_type.lower(),\n                'user_id': self.user_id.value,\n                'reason': self.reason.value or 'No reason given',\n                'timestamp': datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')\n            })\n\n            await interaction.response.send_message(action_msg, ephemeral=False)\n\n        except discord.Forbidden:\n            await interaction.response.send_message('Bot lacks permissions to perform this action.', ephemeral=True)\n        except Exception as e:\n            await interaction.response.send_message(f'Error performing action: {e}', ephemeral=True)\n\nclass ActionSelect(discord.ui.Select):\n    def __init__(self):\n        options = [\n            discord.SelectOption(label='Unban', value='Unban', description='Remove a ban for the user'),\n            discord.SelectOption(label='Untimeout', value='Untimeout', description='Remove timeout from the user'),\n            discord.SelectOption(label='Unkick', value='Unkick', description='Record that a kick was overturned'),\n        ]\n        super().__init__(placeholder='Select the action to undo...', min_values=1, max_values=1, options=options)\n\n    async def callback(self, interaction: discord.Interaction):\n        modal = AcceptModal(self.values[0])\n        await interaction.response.send_modal(modal)\n\nclass ActionView(discord.ui.View):\n    def __init__(self):\n        super().__init__(timeout=300)\n        self.add_item(ActionSelect())\n\nawait interaction.response.send_message('Select the action to undo:', view=ActionView(), ephemeral=True)",
        "hello": "await interaction.response.send_message('hello! The bot is working.', ephemeral=True)",
        "llm": "import aiohttp, discord\n\nclass LLMPromptModal(discord.ui.Modal, title=\"LLM Prompt\"):\n    prompt = discord.ui.TextInput(label=\"Prompt\", style=discord.TextStyle.paragraph, placeholder=\"Enter your prompt here...\", required=True)\n\n    async def on_submit(self, interaction: discord.Interaction):\n        await interaction.response.defer()\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post('http://localhost:11434/api/generate', json={'model': 'smollm2:135m', 'prompt': self.prompt.value, 'stream': False}) as resp:\n                    if resp.status == 200:\n                        data = await resp.json()\n                        await interaction.followup.send(data.get('response', 'Empty'), ephemeral=True)\n                    else:\n                        await interaction.followup.send('Ollama Error', ephemeral=True)\n        except (aiohttp.ClientConnectorError, ConnectionRefusedError):\n            await interaction.followup.send('\u274c Ollama is not available. Please ensure Ollama is running on localhost:11434.', ephemeral=True)\n        except Exception as e:\n            await interaction.followup.send(f'Error: {e}', ephemeral=True)\n\nawait interaction.response.send_modal(LLMPromptModal())",
        "greet": "import json\r\nimport os\r\n\r\n# Check if user has interacted before by checking a simple file-based tracking system\r\nusers_file = \"users.json\"\r\nuser_id = str(interaction.user.id)\r\n\r\nif os.path.exists(users_file):\r\n    with open(users_file, \"r\") as f:\r\n        users = json.load(f)\r\nelse:\r\n    users = {}\r\n\r\nif user_id not in users:\r\n    users[user_id] = {\"first_interaction\": True}\r\n    with open(users_file, \"w\") as f:\r\n        json.dump(users, f)\r\n    \r\n    await interaction.response.send_message(\r\n        \"Welcome! This is your first command. To access logs, visit: http://YOUR_SERVER_IP:5000\\n\"\r\n        \"If you need to appeal a ban, please follow the instructions on the appeals page.\"\r\n    )\r\nelse:\r\n    await interaction.response.defer()"
    }
}