{
    "token": "YOUR_BOT_TOKEN_HERE",
    "log_channel_id": "YOUR_LOG_CHANNEL_ID_HERE",
    "main_server": "YOUR_MAIN_SERVER_ID_HERE",
    "app_server": "application server (PLANNED FOR THE FUTURE)",
    "custom_commands": {
        "sync": "await client.tree.sync(guild=interaction.guild)\nawait interaction.response.send_message(\"Guild commands synced successfully.\", ephemeral=True)",
        "ban": "import discord, json, os\nfrom datetime import datetime\nfrom log_helper import add_log\n\nclass BanModal(discord.ui.Modal, title=\"Ban User\"):\n    user_id = discord.ui.TextInput(label=\"User ID\", placeholder=\"User ID here\", required=True)\n    reason = discord.ui.TextInput(label=\"Reason\", style=discord.TextStyle.paragraph, required=False)\n\n    async def on_submit(self, interaction: discord.Interaction):\n        try:\n            user = discord.Object(id=int(self.user_id.value))\n            await interaction.guild.ban(user, reason=self.reason.value)\n            # ----- LOGGING -----\n            add_log({\n                \"type\": \"ban\",\n                \"user_id\": self.user_id.value,\n                \"reason\": self.reason.value or \"No reason given\",\n                \"timestamp\": datetime.utcnow().strftime(\"%Y-%m-%d %H:%M:%S\")\n            })\n            await interaction.response.send_message(f\"Banned user {self.user_id.value}.\", ephemeral=True)\n        except Exception as e:\n            await interaction.response.send_message(f\"Error: {e}\", ephemeral=True)\n\nawait interaction.response.send_modal(BanModal())",
        "kick": "import discord, json, os\nfrom datetime import datetime\nfrom log_helper import add_log\n\nclass KickModal(discord.ui.Modal, title=\"Kick User\"):\n    user_id = discord.ui.TextInput(label=\"User ID\", placeholder=\"User ID here\", required=True)\n    reason = discord.ui.TextInput(label=\"Reason\", style=discord.TextStyle.paragraph, required=False)\n\n    async def on_submit(self, interaction: discord.Interaction):\n        try:\n            member = interaction.guild.get_member(int(self.user_id.value))\n            if member:\n                await member.kick(reason=self.reason.value)\n                # ----- LOGGING -----\n                add_log({\n                    \"type\": \"kick\",\n                    \"user_id\": self.user_id.value,\n                    \"reason\": self.reason.value or \"No reason given\",\n                    \"timestamp\": datetime.utcnow().strftime(\"%Y-%m-%d %H:%M:%S\")\n                })\n                await interaction.response.send_message(f\"Kicked {member.name}.\", ephemeral=True)\n            else:\n                await interaction.response.send_message(\"Member not found.\", ephemeral=True)\n        except Exception as e:\n            await interaction.response.send_message(f\"Error: {e}\", ephemeral=True)\n\nawait interaction.response.send_modal(KickModal())",
        "timeout": "import discord, json, os\nfrom datetime import datetime, timedelta\nfrom log_helper import add_log\n\nclass TimeoutModal(discord.ui.Modal, title=\"Timeout User\"):\n    user_id = discord.ui.TextInput(label=\"User ID\", placeholder=\"User ID here\", required=True)\n    minutes = discord.ui.TextInput(label=\"Duration (Minutes)\", placeholder=\"60\", required=True)\n    reason = discord.ui.TextInput(label=\"Reason\", style=discord.TextStyle.paragraph, required=False)\n\n    async def on_submit(self, interaction: discord.Interaction):\n        try:\n            member = interaction.guild.get_member(int(self.user_id.value))\n            if member:\n                duration = timedelta(minutes=int(self.minutes.value))\n                await member.timeout(duration, reason=self.reason.value)\n                # ----- LOGGING -----\n                add_log({\n                    \"type\": \"timeout\",\n                    \"user_id\": self.user_id.value,\n                    \"reason\": self.reason.value or f\"Timed out for {self.minutes.value} minutes\",\n                    \"timestamp\": datetime.utcnow().strftime(\"%Y-%m-%d %H:%M:%S\")\n                })\n                await interaction.response.send_message(f\"Timed out {member.name} for {self.minutes.value}m.\", ephemeral=True)\n            else:\n                await interaction.response.send_message(\"Member not found.\", ephemeral=True)\n        except Exception as e:\n            await interaction.response.send_message(f\"Error: {e}\", ephemeral=True)\n\nawait interaction.response.send_modal(TimeoutModal())",
        "accept": "class AcceptModal(discord.ui.Modal, title=\"Accept Appeal\"):\n    user_id = discord.ui.TextInput(label=\"User ID\", placeholder=\"User ID to Unban\", required=True)\n    reason = discord.ui.TextInput(label=\"Unban Reason\", style=discord.TextStyle.paragraph, required=False)\n\n    async def on_submit(self, interaction: discord.Interaction):\n        try:\n            user = discord.Object(id=int(self.user_id.value))\n            await interaction.guild.unban(user, reason=self.reason.value)\n            await interaction.response.send_message(f\"Appeal Accepted. Unbanned <@{self.user_id.value}>.\", ephemeral=False)\n        except Exception as e:\n            await interaction.response.send_message(f\"Error unbanning: {e}\", ephemeral=True)\n\nawait interaction.response.send_modal(AcceptModal())",
        "deny": "class DenyModal(discord.ui.Modal, title=\"Deny Appeal\"):\n    user_id = discord.ui.TextInput(label=\"User ID\", placeholder=\"User ID\", required=True)\n    reason = discord.ui.TextInput(label=\"Denial Reason\", style=discord.TextStyle.paragraph, required=True)\n\n    async def on_submit(self, interaction: discord.Interaction):\n        await interaction.response.send_message(f\"Appeal Denied for <@{self.user_id.value}>.\\nReason: {self.reason.value}\", ephemeral=False)\n\nawait interaction.response.send_modal(DenyModal())",
        "hello": "await interaction.response.send_message('hello! The bot is working.', ephemeral=True)",
        "llm": "import aiohttp, discord\n\nclass LLMPromptModal(discord.ui.Modal, title=\"LLM Prompt\"):\n    prompt = discord.ui.TextInput(label=\"Prompt\", style=discord.TextStyle.paragraph, placeholder=\"Enter your prompt here...\", required=True)\n\n    async def on_submit(self, interaction: discord.Interaction):\n        await interaction.response.defer()\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post('http://localhost:11434/api/generate', json={'model': 'qwen3:0.6b', 'prompt': self.prompt.value, 'stream': False}) as resp:\n                    if resp.status == 200:\n                        data = await resp.json()\n                        await interaction.followup.send(data.get('response', 'Empty'), ephemeral=True)\n                    else:\n                        await interaction.followup.send('Ollama Error', ephemeral=True)\n        except Exception as e:\n            await interaction.followup.send(f'Error: {e}', ephemeral=True)\n\nawait interaction.response.send_modal(LLMPromptModal())",
        "greet": "import json\r\nimport os\r\n\r\n# Check if user has interacted before by checking a simple file-based tracking system\r\nusers_file = \"users.json\"\r\nuser_id = str(interaction.user.id)\r\n\r\nif os.path.exists(users_file):\r\n    with open(users_file, \"r\") as f:\r\n        users = json.load(f)\r\nelse:\r\n    users = {}\r\n\r\nif user_id not in users:\r\n    users[user_id] = {\"first_interaction\": True}\r\n    with open(users_file, \"w\") as f:\r\n        json.dump(users, f)\r\n    \r\n    await interaction.response.send_message(\r\n        \"Welcome! This is your first command. To access logs, visit: http://YOUR_SERVER_IP:5000\\n\"\r\n        \"If you need to appeal a ban, please follow the instructions on the appeals page.\"\r\n    )\r\nelse:\r\n    await interaction.response.defer()"
    }
}